# Gemini Design Overview

Gemini is an open source cluster manager, responsible for deploying, managing, and maintaining clustering systems.

Gemini provides primitives for maintaining the desired state requested by the user. These primitives are the main value added by Gemini. Self-healing mechanisms, such as auto-restarting, re-scheduling, and replicating clusters require active controllers.

Gemini currently supports the Kubernetes clustering system. However, the intent of Gemini is to support multiple clustering systems such as Mesos, Swarm and others. It is also designed to facilitate migration of non-containerized application stacks. It therefore includes abstractions for grouping clusters in both loosely coupled and tightly coupled formations, and provides ways for clusters to communicate with each other in relatively familiar ways.

Gemini enables users create and run one or more clusters across different deployment types, such as bare metal servers, virtual machines, and clouds. The system automatically configures and manages the underlying componenents such as provisioning servers, installaing an operating system, configuring clustering system software, etc.. While Gemini's scheduler is currently very simple, we expect it to grow in sophistication over time. Scheduling is a policy-rich, topology-aware, cluster-specific function that significantly impacts availability, performance, and capacity. The scheduler needs to take into account individual and collective resource requirements, quality of service requirements, hardware/software/policy constraints, affinity and anti-affinity specifications, data locality, inter-cluster interference, deadlines, and so on. Cluster-specific requirements will be exposed through the API as necessary.

Gemini is intended to run on a number of cloud providers, as well as on-premis.

A single Gemini cluster is not intended to span multiple availability zones, regions, cloud providers, etc.. Instead, multiple clusters should be deployed and applications should be configured for high availability across the clusters.

Finally, Gemini aspires to be an extensible, pluggable, building-block OSS platform and toolkit. Therefore, architecturally, we want Gemini to be built as a collection of pluggable components and layers, with the ability to use alternative clustering systems, deployments types, operating systems, etc. and we're evolving its current code in that direction. Furthermore, we want others to be able to extend Gemini functionality, such as with higher-level PaaS functionality, without modification of core Gemini source. Therefore, its API isn't just (or even necessarily mainly) targeted at end users, but at tool and extension developers. Its APIs are intended to serve as the foundation for an open ecosystem of tools, automation systems, and higher-level API layers. Consequently, there are no "internal" inter-component APIs. All APIs are visible and available, including the APIs used by the scheduler, the cluster controller, the replication-controller manager, etc. There's no glass to break -- in order to handle more complex use cases, one can just access the lower-level APIs in a fully transparent, composable manner.
